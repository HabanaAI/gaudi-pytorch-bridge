/*******************************************************************************
 * Copyright (C) 2021-2023 Habana Labs, Ltd. an Intel Company
 * All Rights Reserved.
 *
 * Unauthorized copying of this file or any element(s) within it, via any medium
 * is strictly prohibited.
 * This file contains Habana Labs, Ltd. proprietary and confidential information
 * and is subject to the confidentiality and license agreements under which it
 * was provided.
 *
 *******************************************************************************
 */

/*******************************************************************************
 * INTEL CONFIDENTIAL
 * Copyright 2018-2020 Intel Corporation.
 *
 * This software and the related documents are Intel copyrighted materials, and
 * your use of them is governed by the express license under which they were
 * provided to you ("License"). Unless the License provides otherwise, you may
 * not use, modify, copy, publish, distribute, disclose or transmit this
 * software or the related documents without Intel's prior written permission.
 *
 * This software and the related documents are provided as is, with no express
 * or implied warranties, other than those that are expressly stated in
 * the License.
 *******************************************************************************
 */

// Env definitions are no longer stored in this file.
// To add a new definition please use:
// .../src/pytorch-integration/scripts/env_flags.yaml
// All needed files will be autogenerated based on this YAML file.

#include "backend/synapse_helpers/env_flags.h"

#include <cerrno>
#include <cstdlib>

#include <algorithm>
#include <cctype>
#include <ostream>
#include <string>
#include <utility>

#include <absl/strings/match.h>

#include "habana_helpers/logging.h"

namespace env_flags {

template <class T>
static RT<T> env_value(T v) {
  return std::make_pair(v, true);
}

template <class T>
static RT<T> default_value(T v) {
  return std::make_pair(v, false);
}

// getenv("XXX") returns:
// 1. No XXX definition --> nullptr
// 2. XXX= --> ""
// 3. XXX=asdf --> "asdf"

template <>
RT<const char*> getenv_by_type(const char* name, const char* def_val) {
  // Conversion to string:
  //   |    env var      |   returned value
  // ----------------------------------------
  // 1 | XXX undefined   |   default value
  // 2 | XXX=            |   default value
  // 3 | XXX=asdf        |   "asdf"
  const char* e = getenv(name);
  return e && *e ? env_value(e) : default_value(def_val);
}

template <class T, class F>
static RT<T> getenv_numeric(
    const char* name,
    T def_val,
    T min_val,
    T max_val,
    F strtonum) {
  // Conversion to number:
  //   |    env var      |   returned value  |    LOG
  // -------------------------------------------------------------
  // 1 | XXX undefined   |   default value   |
  // 2 | XXX=            |   default value   |
  // 3 | XXX=123         |   0x7b            |
  // 4 | XXX=abcd        |   0xabcd          |
  // 5 | XXX=0xabcd      |   0xabcd          |
  // 6 | XXX=1234asdf    |   Invalid         | syntax error "asdf"
  // 7 | XXX=asdf        |   Invalid         | syntax error "asdf"
  // 8 | XXX=123...789   |   Invalid         | overflow error
  const char* envstrp = getenv(name);
  if (envstrp && *envstrp) {
    // getenv returned a valid string

    // Only case that we need to handle is hex numbers without 0x prefix
    std::string envstr_lc{envstrp};
    std::string envstr_orig{envstrp};

    // Using a lowercase representation
    std::transform(
        envstr_lc.begin(),
        envstr_lc.end(),
        envstr_lc.begin(),
        [](unsigned char c) { return std::tolower(c); });

    const std::string hex_qual{"0x"};
    if (envstr_lc.find(hex_qual) != 0 &&
        std::any_of(
            std::begin(envstr_lc), std::end(envstr_lc), [](unsigned char c) {
              return (c >= 'a' && c <= 'f');
            })) {
      envstr_lc.insert(0, hex_qual);
      envstrp = envstr_lc.c_str();
    }

    errno = 0;
    char* endptr;
    T envval = static_cast<T>(strtonum(envstrp, &endptr, 0));
    if (errno == ERANGE) {
      PT_SYNHELPER_FATAL(
          "Environment variable \"",
          name,
          "\"=\"",
          envstr_orig,
          "\" converted to different value \"",
          envval,
          "\" due to underflow/overflow.");
    } else if (errno != 0) {
      PT_SYNHELPER_FATAL(
          "Environment variable \"",
          name,
          "\"=\"",
          envstr_orig,
          "\" is not converted properly.");
    }

    // Nonnull endptr means incorrect input string
    // Report syntax error and assert
    if (*endptr) {
      PT_SYNHELPER_FATAL(
          "Environment variable \"",
          name,
          "\"=\"",
          envstr_orig,
          "\" converted to different value \"",
          envval,
          "\" due to syntax error.");
    }

    // Range check and report the error and assert for overflow / underflow
    if ((envval < min_val) || (envval > max_val)) {
      PT_SYNHELPER_FATAL(
          "Environment variable \"",
          name,
          "\"=\"",
          envstr_orig,
          "\" decoded as ",
          envval,
          " is out of range <",
          min_val,
          ", ",
          max_val,
          ">");
    }

    // Return conversion result
    PT_SYNHELPER_DEBUG(
        "Environment variable \"",
        name,
        "\"=\"",
        envstr_orig,
        "\" is decoded as ",
        envval,
        '\"');
    return env_value(envval);
  } else {
    // Both undefined and XXX= cases
    return default_value(def_val);
  }
}

template <>
RT<bool> getenv_by_type(const char* name, bool def_val) {
  const char* envstrp = getenv(name);
  if (envstrp && *envstrp) {
    bool true_found = absl::EqualsIgnoreCase(envstrp, "1") ||
        absl::EqualsIgnoreCase(envstrp, "true");
    bool false_found = absl::EqualsIgnoreCase(envstrp, "0") ||
        absl::EqualsIgnoreCase(envstrp, "false");

    if (true_found)
      return env_value(true);
    else if (false_found)
      return env_value(false);
    else {
      PT_SYNHELPER_FATAL(
          "Environment variable \"",
          name,
          "\"=\"",
          envstrp,
          "\" converted to default value \"",
          def_val,
          "\" due to syntax error");
    }
  }

  return default_value(def_val);
}

#define INST_GETENV_BY_TYPE(T, conv)                                        \
  template <>                                                               \
  RT<T> getenv_by_type(const char* name, T def_val, T min_val, T max_val) { \
    return getenv_numeric(name, def_val, min_val, max_val, conv);           \
  }

INST_GETENV_BY_TYPE(int, strtol)
INST_GETENV_BY_TYPE(long, strtol)
INST_GETENV_BY_TYPE(unsigned, strtoul)
INST_GETENV_BY_TYPE(unsigned long, strtoul)
INST_GETENV_BY_TYPE(long long, strtoll)
INST_GETENV_BY_TYPE(unsigned long long, strtoull)

// ****************************************************************************
// New style of env var declaration

namespace new_style {

const char* getenv_by_type_new(
    const char* name,
    const bool& skip_cache,
    bool& is_cached,
    bool& is_defined,
    std::string& act_val,
    const char* def_val) {
  // Conversion to string:
  //   |    env var      |   returned value
  // ----------------------------------------
  // 1 | XXX undefined   |   default value
  // 2 | XXX=asdf        |   "asdf"
  if (!is_cached || skip_cache) {
    const char* envstrp = getenv(name);
    if (envstrp && *envstrp) {
      act_val = envstrp;
      is_defined = true;
    } else {
      act_val = def_val;
    }
    is_cached = true;
  }
  return act_val.c_str();
}

static bool parse_env_bool(const char* name, const char* value) {
  bool result = false;
  bool true_found = absl::EqualsIgnoreCase(value, "1") ||
      absl::EqualsIgnoreCase(value, "true");
  bool false_found = absl::EqualsIgnoreCase(value, "0") ||
      absl::EqualsIgnoreCase(value, "false");

  if (true_found)
    result = true;
  else if (false_found)
    result = false;
  else {
    PT_SYNHELPER_FATAL(
        "Environment variable \"",
        name,
        "\"=\"",
        value,
        "\" couldn't be converted properly");
  }
  return result;
}

bool getenv_by_type_new(
    const char* name,
    const bool& skip_cache,
    bool& is_cached,
    bool& is_defined,
    bool& act_val,
    bool def_val,
    bool min_val,
    bool max_val) {
  (void)min_val;
  (void)max_val;
  if (!is_cached || skip_cache) {
    bool result = def_val;
    const char* envstrp = getenv(name);
    if (envstrp && *envstrp) {
      result = parse_env_bool(name, envstrp);
      is_defined = true;
    }
    act_val = result;
    is_cached = true;
  }
  return act_val;
}

template <class T, class F>
static T parse_env_numeric(
    const char* name,
    const char* value,
    T min_val,
    T max_val,
    F func_strtonum) {
  // Only case that we need to handle is hex numbers without 0x prefix
  std::string envstr_lc{value};
  std::string envstr_orig{value};

  // Using a lowercase representation
  std::transform(
      envstr_lc.begin(),
      envstr_lc.end(),
      envstr_lc.begin(),
      [](unsigned char c) { return std::tolower(c); });

  const std::string hex_qual{"0x"};
  if (envstr_lc.find(hex_qual) != 0 &&
      std::any_of(
          std::begin(envstr_lc), std::end(envstr_lc), [](unsigned char c) {
            return (c >= 'a' && c <= 'f');
          })) {
    envstr_lc.insert(0, hex_qual);
    value = envstr_lc.c_str();
  }

  errno = 0;
  char* endptr;
  T envval = static_cast<T>(func_strtonum(value, &endptr, 0));
  if (errno == ERANGE) {
    PT_SYNHELPER_FATAL(
        "Environment variable \"",
        name,
        "\"=\"",
        envstr_orig,
        "\" converted to different value \"",
        envval,
        "\" due to underflow/overflow.");
  } else if (errno != 0) {
    PT_SYNHELPER_FATAL(
        "Environment variable \"",
        name,
        "\"=\"",
        envstr_orig,
        "\" is not converted properly.");
  }

  // Nonnull endptr means incorrect input string
  // Report syntax error and assert
  if (*endptr) {
    PT_SYNHELPER_FATAL(
        "Environment variable \"",
        name,
        "\"=\"",
        envstr_orig,
        "\" converted to different value \"",
        envval,
        "\" due to syntax error.");
  }

  // Range check and report the error and assert for overflow / underflow
  if ((envval < min_val) || (envval > max_val)) {
    PT_SYNHELPER_FATAL(
        "Environment variable \"",
        name,
        "\"=\"",
        envstr_orig,
        "\" decoded as ",
        envval,
        " is out of range <",
        min_val,
        ", ",
        max_val,
        ">");
  }

  // Return conversion result
  PT_SYNHELPER_DEBUG(
      "Environment variable \"",
      name,
      "\"=\"",
      envstr_orig,
      "\" is decoded as ",
      envval,
      '\"');

  return envval;
}

template <class T, class F>
static T getenv_numeric_new(
    const char* name,
    const bool& skip_cache,
    bool& is_cached,
    bool& is_defined,
    T& act_val,
    T def_val,
    T min_val,
    T max_val,
    F func_strtonum) {
  // Conversion to number:
  //   |    env var      |   returned value  |    LOG
  // -------------------------------------------------------------
  // 1 | XXX undefined   |   default value   |
  // 2 | XXX=            |   default value   |
  // 3 | XXX=123         |   0x7b            |
  // 4 | XXX=abcd        |   0xabcd          |
  // 5 | XXX=0xabcd      |   0xabcd          |
  // 6 | XXX=1234asdf    |   Invalid         | syntax error "asdf"
  // 7 | XXX=asdf        |   Invalid         | syntax error "asdf"
  // 8 | XXX=123...789   |   Invalid         | overflow error
  if (!is_cached || skip_cache) {
    const char* envstrp = getenv(name);
    if (envstrp && *envstrp) {
      act_val =
          parse_env_numeric(name, envstrp, min_val, max_val, func_strtonum);
      is_defined = true;
    } else {
      act_val = def_val;
    }
    is_cached = true;
  }
  return act_val;
}

#define INSTANTIATE_GETENV_BY_TYPE_NEW(T, conv) \
  template <>                                   \
  T getenv_by_type_new(                         \
      const char* name,                         \
      const bool& skip_cache,                   \
      bool& is_cached,                          \
      bool& is_defined,                         \
      T& act_val,                               \
      T def_val,                                \
      T min_val,                                \
      T max_val) {                              \
    return getenv_numeric_new(                  \
        name,                                   \
        skip_cache,                             \
        is_cached,                              \
        is_defined,                             \
        act_val,                                \
        def_val,                                \
        min_val,                                \
        max_val,                                \
        conv);                                  \
  }

INSTANTIATE_GETENV_BY_TYPE_NEW(int, strtol)
INSTANTIATE_GETENV_BY_TYPE_NEW(long, strtol)
INSTANTIATE_GETENV_BY_TYPE_NEW(unsigned, strtoul)
INSTANTIATE_GETENV_BY_TYPE_NEW(unsigned long, strtoul)
INSTANTIATE_GETENV_BY_TYPE_NEW(long long, strtoll)
INSTANTIATE_GETENV_BY_TYPE_NEW(unsigned long long, strtoull)

#define INSTANTIATE_PARSE_ENV_BY_TYPE_NEW(T, conv)              \
  template <>                                                   \
  T parse_env_by_type<T>(const char* name, const char* value) { \
    T parsed = parse_env_numeric(                               \
        name,                                                   \
        value,                                                  \
        std::numeric_limits<T>::min(),                          \
        std::numeric_limits<T>::max(),                          \
        conv);                                                  \
    return parsed;                                              \
  }

INSTANTIATE_PARSE_ENV_BY_TYPE_NEW(int, strtol)
INSTANTIATE_PARSE_ENV_BY_TYPE_NEW(long, strtol)
INSTANTIATE_PARSE_ENV_BY_TYPE_NEW(unsigned, strtoul)
INSTANTIATE_PARSE_ENV_BY_TYPE_NEW(unsigned long, strtoul)
INSTANTIATE_PARSE_ENV_BY_TYPE_NEW(long long, strtoll)
INSTANTIATE_PARSE_ENV_BY_TYPE_NEW(unsigned long long, strtoull)

template <>
bool parse_env_by_type<bool>(const char* name, const char* value) {
  bool parsed = parse_env_bool(name, value);
  return parsed;
}

// Env definitions are no longer stored in this file.
// To add a new definition please use:
// .../src/pytorch-integration/scripts/env_flags.yaml
// All needed files will be autogenerated based on this YAML file.

} // namespace new_style

// ****************************************************************************

} // namespace env_flags

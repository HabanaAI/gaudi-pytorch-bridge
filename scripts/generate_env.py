###############################################################################
#
#  Copyright (c) 2021-2024 Intel Corporation
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
###############################################################################

# Automatically generates environmental variables:
#
# In directory:
#   qnpu/1.13.0-124/bin/pytorch_modules_multi_build/torch/py3.8/pt2.0.1/Release/generated/env_flags/
#
# List of files:
#   env_flags_generated.h
#   env_flags_definition_generated.cpp
#   Bindings.cpp
#   bridge_config.py
#
# Input data comes from TPC kernels listed in:
#   pytorch-integration/scripts/env_flags.yaml

import argparse
import os
import textwrap

import yaml

parser = argparse.ArgumentParser()
parser.add_argument("--yaml", "-y", type=str, required=False, default="env_flags.yaml")
parser.add_argument(
    "--output_dir",
    "-o",
    type=str,
    required=False,
    default="../../../bin/pytorch_modules_multi_build/torch/py3.8/pt2.0.1/Release/generated/env_flags",
)

parser.add_argument(
    "--python_output_dir",
    "-p",
    type=str,
    required=False,
    default="../../../bin/pytorch_modules_multi_build/torch/py3.8/pt2.0.1/Release/generated/env_flags",
)

copyright_header = '\
/**\n\
* Copyright (c) 2021-2024 Intel Corporation\n\
*\n\
* Licensed under the Apache License, Version 2.0 (the "License");\n\
* you may not use this file except in compliance with the License.\n\
* You may obtain a copy of the License at\n\
*     http://www.apache.org/licenses/LICENSE-2.0\n\
*\n\
* Unless required by applicable law or agreed to in writing, software\n\
* distributed under the License is distributed on an "AS IS" BASIS,\n\
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\
* See the License for the specific language governing permissions and\n\
* limitations under the License.\n\
*/\n\
\n\
// The file is autogenerated by generate_env.py script based on\n\
// env_flags.yaml configuration file. Do not edit this file directly!\n'

python_copyright_header = '\
#\n\
# Copyright (c) 2021-2024 Intel Corporation\n\
#\n\
# Licensed under the Apache License, Version 2.0 (the "License");\n\
# you may not use this file except in compliance with the License.\n\
# You may obtain a copy of the License at\n\
#     http://www.apache.org/licenses/LICENSE-2.0\n\
#\n\
# Unless required by applicable law or agreed to in writing, software\n\
# distributed under the License is distributed on an "AS IS" BASIS,\n\
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\
# See the License for the specific language governing permissions and\n\
# limitations under the License.\n\
#\n\
\n\
# The file is autogenerated by generate_env.py script based on\n\
# env_flags.yaml configuration file. Do not edit this file directly!\n'

flags_include = '\
#include "backend/synapse_helpers/env_flags_impl.h"\n\n'

generated_include = '\
#include "env_flags_generated.h"\n\n'

python_include = "\
import habana_frameworks.torch.internal._bridge_config_C as bc\n\n"

python_tools = "\
from contextlib import contextmanager\n\
@contextmanager\n\
def env_setting(var, val):\n\
    get_func = globals()['get_' + var.lower()]\n\
    set_func = globals()['set_' + var.lower()]\n\
    current = get_func()\n\
    set_func(val)\n\
    yield\n\
    set_func(current)\n\n"

env_namespaces = "\
using namespace env_flags::new_style;\n\
namespace env_flags {\n\
namespace new_style {\n\n"

cpp_binding_block = "\
#include <pybind11/pybind11.h>\n\
PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {\n\n"

close_namespace = "\n\
} // namespace new_style\n\
} // namespace env_flags\n"

cpp_binding_block_close = "\n\
    } // PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {\n\n"


def create_comment(text):
    cpp_comment = "\n" + textwrap.indent(text, "// ") + "\n"
    py_comment = textwrap.indent(text, "# ") + "\n"
    return cpp_comment, py_comment


def generate_bindings_get(flag):
    python_name = "get_" + flag.lower()
    cpp_bindings = 'm.def("' + python_name + '", []() { return GET_ENV_FLAG_NEW(' + flag + "); });\n"
    python_bindings = "def " + python_name + "():\n    return bc." + python_name + "()\n"
    return cpp_bindings, python_bindings


def generate_bindings_set(dictionary, flag):
    python_name = "set_" + flag.lower()
    python_bindings = "def " + python_name + "(value):\n    bc." + python_name + "(value)\n"
    if "type" not in dictionary[flag]:
        cpp_bindings = (
            'm.def("'
            + python_name
            + '", [](std::string value) { SET_ENV_FLAG_NEW('
            + flag
            + ", value.c_str(), 1); });\n"
        )
    else:
        cpp_bindings = (
            'm.def("'
            + python_name
            + '", []('
            + dictionary[flag]["type"]
            + " value) { SET_ENV_FLAG_NEW("
            + flag
            + ", value, 1); });\n"
        )

    return cpp_bindings, python_bindings


def generate_bindings(dictionary, flag):
    cpp_bindings_get, python_bindings_get = generate_bindings_get(flag)
    cpp_binding_line = cpp_bindings_get
    python_binding_line = python_bindings_get

    if "settable" in dictionary[flag] and dictionary[flag]["settable"] == True:
        cpp_bindings_set, python_bindings_set = generate_bindings_set(dictionary, flag)
        cpp_binding_line += cpp_bindings_set
        python_binding_line += python_bindings_set

    return cpp_binding_line, python_binding_line


def value_to_str(value):
    return str(value).lower() if type(value) is bool else str(value)


def generate_env(dictionary):
    cpp_bindings = generated_include + cpp_binding_block
    cpp_code = flags_include + env_namespaces
    cpp_definition = generated_include + env_namespaces
    python_code = python_include + python_tools

    for flag in dictionary:
        cpp_comment = ""
        cpp_line = ""
        cpp_definition_line = ""
        py_comment = ""

        if "doc" in dictionary[flag]:
            cpp_comment, py_comment = create_comment(dictionary[flag]["doc"])

        if "type" not in dictionary[flag]:
            cpp_line += "ENV_STRING_STRUCT_DEFINITION(" + flag + ', "' + str(dictionary[flag]["default"]) + '");'
            cpp_definition_line += "ENV_STRING_STRUCT_STATIC_DEFINITION(" + flag + ");"
        else:
            cpp_line += (
                "ENV_STRUCT_DEFINITION("
                + flag
                + ", "
                + str(dictionary[flag]["type"])
                + ", "
                + value_to_str(dictionary[flag]["default"])
                + ");"
            )
            cpp_definition_line += "ENV_STRUCT_STATIC_DEFINITION(" + flag + ", " + str(dictionary[flag]["type"]) + ");"

        cpp_binding_line, python_binding_line = generate_bindings(dictionary, flag)

        cpp_code += cpp_comment + cpp_line + "\n"
        cpp_definition += cpp_comment + cpp_definition_line + "\n"
        cpp_bindings += cpp_comment + cpp_binding_line + "\n"
        python_code += py_comment + python_binding_line + "\n"

    cpp_bindings += cpp_binding_block_close
    cpp_code += close_namespace
    cpp_definition += close_namespace
    return cpp_code, cpp_definition, cpp_bindings, python_code


def createOutputDirectory(output_dir):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print("Created directory for environmental variables.")
    else:
        print("Directory for environmental variables already exists.")


def main():
    print("Calling Environmental variables generation...")
    args = parser.parse_args()
    print("YAML file: ", args.yaml)
    print("Output directory: ", args.output_dir)
    print("Python output directory: ", args.python_output_dir)

    with open(args.yaml) as file:
        try:
            env_flags_yaml = yaml.safe_load(file)
        except yaml.YAMLError as e:
            print(e)

    createOutputDirectory(args.output_dir)
    cpp_code, cpp_definition, cpp_bindings, python_code = generate_env(env_flags_yaml)

    with open(args.output_dir + "/env_flags_generated.h", "w") as cpp_output:
        cpp_output.write(copyright_header)
        cpp_output.write("#pragma once\n\n")
        cpp_output.write(cpp_code)

    with open(args.output_dir + "/env_flags_definition_generated.cpp", "w") as cpp_output:
        cpp_output.write(copyright_header)
        cpp_output.write(cpp_definition)

    with open(args.output_dir + "/Bindings.cpp", "w") as cpp_output:
        cpp_output.write(copyright_header)
        cpp_output.write(cpp_bindings)

    with open(args.python_output_dir + "/bridge_config.py", "w") as py_output:
        py_output.write(python_copyright_header)
        py_output.write(python_code)

    print("Environmental variables have been generated: " + args.output_dir + "/env_flags_generated.h")
    print(
        "Environmental variables definition have been generated: "
        + args.output_dir
        + "/env_flags_definition_generated.h"
    )
    print("Bindings have been generated: " + args.output_dir + "/Bindings.cpp")
    print("Python bridge has been generated: " + args.python_output_dir + "/bridge_config.py")


if __name__ == "__main__":
    main()
